/*
 * KMeanAlgo.h
 *
 *  Created on: Nov 4, 2020
 *      Author: gratienj
 */

#ifndef SRC_IMGPROCESSING_KMEANALGO_H_
#define SRC_IMGPROCESSING_KMEANALGO_H_
#include <cmath>
#include <cstdint>
#define MAX_UCHAR 255
#include <iostream>
#include <time.h>
#include <omp.h>
#include <chrono>
#include <ctime>
#include <limits>


namespace PPTP
{

	class KMeanAlgo
	{

       private:
	       int nbchannels = 3;
	       int nbcentroids = 1;
	       std::vector<uchar> centroids;

       public:
		KMeanAlgo(int nb_channels, int nb_centroids)
	        : nbchannels(nb_channels)
		, nbcentroids(nb_centroids)
		{
		  centroids.reserve(nb_channels*nb_centroids);
		}
		
		
		virtual ~KMeanAlgo() {}

		int nearest_centroid(cv::Mat const& pix, std::vector<double> cent)
		    {
			using namespace cv ;

			double z=0;
		      double sum=0;;
		      
		      double r = pix[0] - cent[0];
		      double g = pix[1] - cent[1];
		      double b = pix[2] - cent[2];
		      double min = r*r + g*g + b*b;

		      for(int t=1; t<k;t++)
		      {
		      r = pix[0] - cent[3*t];
		      g = pix[1] - cent[3*t+1];
		      b = pix[2] - cent[3*t+2];
		      sum = r*r + g*g + b*b;

                               if (sum<min)
			       {
			         min = sum; z = t;}
		       }
		    
		        return z;	
	         }

		
		
		double compute_displacement(std::vector<double> cent, std::vector<double> new_cent)
		{
                      using namespace cv ;
		      switch(nb_channels)
		      {
		        case 1:
		          for(std::size_t i=1;i<image.rows-1;++i)
		          {
		            for(int j=1;j<image.cols-1;++j)
		            {
		              uchar pixel = image.at<uchar>(i,j) ;
		            }
		          }
		          break ;
		        case 3:
		          Mat_<Vec3b> _I = image;
		          for(std::size_t i=1;i<image.rows-1;++i)
		          {
		            for(int j=1;j<image.cols-1;++j)
		            {
		              for(int k=0;k<3;++k)
		              {
		                uchar pixel = _I(i,j)[k] ;
		              }
		            }
		          }
		          break ;
		      }
		}

		void process(cv::Mat& image)
		{
			//compute_centroids(image) ;
			//compute_segmentation(image) ;
		}

	private :
	    int m_nb_channels = 3 ;
		int m_nb_centroid = 0 ;
		std::vector<uchar> m_centroids ;
	};
}

#endif /* SRC_IMGPROCESSING_KMEANALGO_H_ */
